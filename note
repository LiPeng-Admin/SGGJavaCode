计算机语言发展迭代史
机器语言->机器语言->高级语言(面向过程，面向对象)
计算机底层都以补码的方式来存储数据
对于正数而言：原码，补码，反码三码合一
对于负数来说，原码除符号位不同(1:表示负数)其他相同
            反码是除符号位与负数的符号位相同外，其他都是反的（负数原码的0变为1,1变为0）
            补码=反码+1
java
在领域的应用：
企业级应用，Android平台应用，大数据平台开发
语言特性：
是一个纯粹的 面向对象 的程序设计语言，继承了C++语言面向对象技术的核心，
舍弃了C语言中容易引起错误的指针，增加了垃圾回收器功能
语言特点：
1、面向对象：
两个基本概念：类，对象
三大特性：封装，继承，多态
2、健壮性：
吸收了C/C++语言的优点，去掉了其影响程序健壮性的部分(如指针，内存的申请与释放)，
                     提供了一个相对安全的内存管理和访问机制
3：跨平台性：
通过java语言编写的应用程序在不同的系统平台上都可以运行
原理：只需要运行java 应用程序的操作系统上，先安装一个Java 虚拟机(JVM Java Virtual Machine)即可
由JVM 负责Java程序在该系统中的运行

核心机制：
java 虚拟机（JVM）
垃圾收集机制

JDK(Java Development Kit Java 开发工具包)
包含了java 的开发工具和JRE
开发工具：
        编译工具（javac.exe）打包工具（jar.exe）等
JRE：
        Java Runtime Environment Java 运行环境
        包括Java虚拟机和Java 程序所需的核心类库等，如果想要运行一个开发好的Java程序，
        计算机中只需要安装安装JRE即可
开发程序：
将java 代码编写到扩展名为.java 的文件中
通过javac 命令对该java 文件进行编译(字节码文件)
通过 java 命令对生成的class 文件进行运行
在一个java 源文件中可以声明多个class ,但是最多有一个类声明为public
且要求声明为public类的类型必须与源文件名相同
每一行执行语句都以";"结束

Java 注释类型
单行注释： //
多行注释：/*  */
单行注释和多行注释特点：不参与编译
文档注释(java特有)：/** */
文档注释特点：注释内容可以被jdk 提供的工具javadoc 解析，
            生成一套以网页文件形式体现的该程序的说明文档
            操作方式：javadoc -d mydoc -author -version HelloWorld.java

Java API 的文档
API（Application Programming Interface）是java 提供的基本编程接口
应用程序=算法+数据结构（主要用于提效）

关键字与保留字
java保留字：现有java 版本尚未使用，但以后版本可能会作为关键字使用，命令标识符要避免使用这些保留字
          如goto ,const

标识符： 定义： java 对各种变量，方法，和类等要素命名时使用的字符序列称为标识符
        技巧： 凡是自己可以起名字的地方都叫标识符
        规则（主要）：由26个英文字母大小写，0-9，_或 $组成
                    数字不可以开头
                    不可以使用关键字和保留字
                    严格区分大小写，长度无限制
                    不能包含空格
         规范：包名：多单词组成时所有字母都小写：xxxyyy
              类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz
              变量名，方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单子首字母大写
                            xxxYyyZzz
              常量名：所有字母都大写，多单词时每个单词用下划线链接:XXX_YYY_ZZZ
Java 中的变量
              是程序中最基本的存储单元，包含变量类型，变量名和存储的值

Java 中的数据类型
               基本数据类型：
                           数值型：整数类型:byte,short,int,long
                                  浮点类型:float,double
                           字符型：char
                           布尔型:boolean
               引用数据类型：
                            类：class  (字符串再这里)
                            接口：interface
                            数组：array

Java 中的运算符
算术运算符，赋值运算符，比较运算符（关系运算符ja），逻辑运算符，位运算符，三元运算符

分支结构
if-else
switch-case

循环结构
for
while
do-while
四个组成部分
初始化部分，
循环条件部分
循环体部分
迭代部分

数组
数组是有序排列的
是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名
数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型
创建的数组对象会在内存中开辟一整块连续的空间
数组的长度一旦确定，就不能修改

获取某个范围的随机数[a,b]:(int)(Math.random()*(b-a+1)+a)


* 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，
* 包括基本数据类型和引用数据类型
* 创建的数组对象会在内存中开辟一整块连续的空间
*数组的长度一旦确定，就不能修改
*
* 一维数组的使用
* 1：一维数组的声明和初始化
* 2：如何调用数组的指定位置的元素
* 3：如何获取数组的长度
* 4：如何遍历数组
* 5：数组元素的默认初始化值
一维数组：
        数组元素是整型：0
        数组元素是浮点型:0.0
        数组元素是char型：0，非'0'
        数组元素是布尔型：false

        数组元素是引用类型：null

二维数组：
        针对初始化方式一：如 int[][]ints=new int[4][3]
        外层元素的初始化值为：地址值
        内层元素的初始化为：整型：0，浮点型：0.0，char型：0,布尔型：false,String 或引用数据类型：null
        针对初始化方式二：如 int[][]ints=new int[4][]
        外层元素的初始化值为：null
        内层元素的初始化：npe 异常

* 6：数组的内存解析

数组中的常见异常
1：数组索引越界的异常
2：空指针异常

算法的常见考查（数组）：
        求数值型数组中元素的最大值，最小值，平均数，总和等
        数组的复制，反转，查找（线性查找,二分法查找）


补充部分
数据结构
1：数据与数据之间的逻辑关系：集合，一对一，一对多，多对多
2：数据的存储结构
线性表：顺序表（如:数组）,链表，栈，队列
树形结构：二叉树
图形结构：

算法：
排序算法
搜索算法

面向对象三条主线
1：java 类及类的成员
2：面向对象的三大特征
3：其他关键字

类和对象是面向对象的核心概念
类是对一类事物的描述，是抽象的，概念上的定义
对象是实际存在的该类事物的每个个体，因而也称为实例

1:设计类，其实就是设计类的成员
    属性=成员变量=field=域、字段
    方法=成员方法=函数=method
    创建类的对象=类的实例化=实例化类
*
2:类和对象的使用
1：创建类，设计类的成员
2：创建类的对象
3：通过"对象.属性"或"对象.方法"调用对象的结构

3:若创建一个类的多个对象，则每个对象都独立的拥有一套类的属性(非static )
    若修改了一个对象的属性a,不影响另外一个对象属性a 的值


类中属性的使用
 属性（成员变量）vs 局部变量
 1： 相同点：
        1.1：定义变量的格式：数据类型 变量名=变量值
        1.2：先声明，后使用
        1.3：变量都有其对应的作用域
 2：不同点：
        2.1:在类中声明的位置不同
        属性（成员变量）：直接定义在类的一对{}内
        局部变量：声明在方法内，方法形参，代码块内，构造器形参，构造器内部的变量
        2.2关于权限修饰符的不同
        属性：可以在声明属性时，指明其权限，使用权限修饰符
        常用的权限修饰符：private,public,缺省,protected,（不写默认是缺省的）==>封装性
        局部变量是不可以使用权限修饰符的
        2.3默认初始化值的情况
        属性：类的属性，根据其类型，都有默认初始化值
              整型：0
              浮点：0.0
              字符型：0
              布尔型：false
              引用数据类型(类，接口，数组)：null

        局部变量:没有默认初始化值，需要显示赋值
                注意:形参在调用时，需要赋值

         2.4 在内存中加载的位置
         属性：加载在堆空间中（非static）
         局部变量：加载在栈空间


类中方法的声明和使用
方法：描述类应该具有的功能
比如：Math类：sqrt()\random()\...
     Scanner类：nextInt()...
     Arrays类：toString()\equals()\...
     1:举例
     public void eat(){}
     public void sleep(int hour){}
     public String getName(){}
     public String getNation(String nation){}

     2:方法的声明：权限修饰符 返回值类型 方法名（形参列表）{
     方法体
     }
     注意：static,final,abstract 来修饰的方法，详见后面

     3：说明：
     3.1关于权限修饰符
        Java规定的4个权限修饰符：private,public,缺省，protected
     3.2返回值类型：有返回值 vs 没有返回值
            3.2.1  如果方法有返回值，则必须在方法声明时，指定返回值的类型，
                    同时，方法中需要使用return 关键字来返回指定类型的变量或常量
                    若方法没有返回值，则方法声明时，使用void来表示，通常，没有返回值的方法中，
                    不需要使用return ，但是，若使用的话，只能只用"return;"来表示结束此方法的意思

            3.2.2 我们定义方法需不需要返回值？
                    1：需求
                    2：经验

       3.3 方法名：属性标识符
       3.4形参列表：方法可以声明0或1个或多个
       格式：数据类型1 形参1,数据类型2 形参2,....

       3.5方法体

      4： return 关键字的作用
       1：适用范围:使用在方法体中
       2：作用：11:结束方法
               22：针对有返回值类型的方法，使用"return 数据"方法返回所要的语句
               33：return 关键字后面不可以声明执行语句

       5:方法的使用中，可以调用当前类的属性和方法
                    特殊的：方法A中又调用了方法A :递归方法
                   方法中不可以定义方法


JVM内存结构
    编译完程序以后，生成一个或多个字节码文件
    我们使用JVM 中的类的加载器和解释器对生成的字节码文件进行解释运行。
    意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析

    虚拟机栈：即平时提到的栈结构。局部变量存在在栈结构中
    堆：     将new 出来的结构（如数组，对象）加载在堆空间中。
            补充：对象的属性（非static）加载在堆空间中
    方法区：  类的加载信息，常量池，静态域

一：理解”万事万物皆对象“
    1：在Java语言范畴中，我们都将功能，结构等封装到类中，通过类的实例化。来调用具体结构的功能结构
    2：涉及到Java 语言与前端Html，后端的数据库交互时，前后端的结构在Java 层面交互时，都体现为类，对象

二：内存解析的说明
    1：引用类型的变量，只可能存储两类值：null或地址值（含变量的类型）

三：匿名对象
    理解：创建的对象，没有显示的付给一个变量名；
          直接 new Phone().属性、方法
    特征： 匿名对象只能调用一次
    使用：

方法
   方法的重载
   *   定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或参数类型不同即可
   *         "两同一不同"：同一个类，相同方法名
   *                     参数列表不同：参数个数不同，参数类型不同
   *   举例：
   *        Arrays类中重载的sort()/binarySearch()
   *
   *   判断是否是重载：
   *         与方法的权限修饰符，返回值类型，形参变量名，方法体没有关系
    示例：
    //返回连个整数的和
    int add(int x,int y){
    return x+y;
    }
    //返回三个整数的和：
    int add(int x,int y,int z){
    return x+y+z
    }
    //返回两个小数的和：
    double add(double x,double y){
    return x+y;
    }

    可变形参的方法
        javaSE5,允许直接定义能和多个实参相匹配的形参。
        1：可变形参的格式：数据类型 ... 变量名
        2:当调用可变个数形参的方法时，传入的参数可以是：0,1,2,。。。
        3:可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
        4：可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载
        5:可变个数形参在方法的形参中，必须声明在末尾
        6：可变个数形参在方法的形参中，最多只能声明一个可变形参


java中方法参数的传递机制： 值传递机制（重难点）
     方法的形参的传递机制：值传递
     * 1：形参：方法定义时，声明在小括号内的参数
     *    实参：方法调用时，实际传递给形参的数据
     *
     * 2：值传递机制
     *   如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值
     *   如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值

     推广：
     关于变量的赋值
          如果变量是基本数据类型，此时赋值的是变量所保存的数据值
          如果变量是引用数据类型，此时复制的是变量所保存的数据地址值


递归方法
    使用
        1：递归方法：一个方法内调用它本身
        2：方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无需循环控制，
           递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环



* 面向对象的特征一：封装与隐藏
* 一：问题的引入
    * 当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值，
    * 这里，赋值操作受到属性的数据类型和存储范围的制约，除此之外，没有其他制约条件。
    * 但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件，这个条件就不能再属性声明时
    * 体现，我们只能通过方法进行限制条件的添加，（如setLegs），同时我们需要避免用户在使用"对象.属性"
    * 的方式来对属性进行赋值，需要将属性声明为私有的（private）->此时，针对于属性就体现为封装性

* 二：封装性的体现
    * 我们将类的属性私有化xxx（private）,同时，提供公共的（public）方法来获取（getXxx）和设置(setXxx)此属性的值
    *   拓展：属性的私有化，方法的私有化，单例模式。。。。

* 三：封装性的体现，需要权限修饰符的配合
    * 1：Java 规定的4种权限（从小到大）：private,缺省,protected,public
    * 2:4种权限可以用来修饰类及类的内部结构：属性，方法，构造器，内部类
    * 3：具体的，4种权限都可以用来修饰符类的内部结构：属性，方法，构造器，内部类
    *           修饰类：只能使用：缺省，public


类的结构之三：构造器（或构造方法）的使用: Constructor
 * 一：构造器的使用
     * 创建对象
     * 给对象初始化
   二：说明
   * 1：如果没哟显示的定义类的构造器的话，则系统默认提供一个空参的构造器
   * 2：定义构造器的格式：
   * 权限修饰符 类名（形参列表）{
   * }
   * 3：类中可以定个多个构造器，彼此构成重载
   * 4：一旦我么定义了类的构造器之后，系统就不在提供了默认的空参构造器
   * 5：一个类中，至少会有一个构造器

 属性赋值
   1：默认初始化
   2：显示初始化
   3：构造器中赋值
   4：通过"对象.方法"或"对象.属性"的方式赋值
赋值 先后顺序 1->2->3->4

 JavaBean 是一种Java 语言写成的可重用组件（符合如下标准的Java 类）
    类是公共的
    有一个无参的公共的构造器
     有属性且有对应的get,set 方法

 this 关键字的使用
 * 1：this 可以用来修饰：属性，方法，构造器
 * 2: this 修饰符属性和方法
     *this理解为：当前对象 或当前正在创建的对象
     *      2.1：在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，来调用当前对象的属性或方法
     *      但是通常情况下，我们会省略"this.",特殊情况下，如果方法的形参与类的属性同名是，我们必须
     *      显示的使用"this.变量"的方式，表明此变量时属性，非形参
     *

      *     2.2在类的构造器中，我们可以使用"this.属性"或"this.方法"的方式，来调用当前正在创建的对象的属性或方法
      *     但是通常情况下，我们会省略"this.",特殊情况下，如果构造器的形参与类的属性同名是，我们必须
      *     显示的使用"this.变量"的方式，表明此变量时属性，非形参
 *3:this   修饰或调用构造器
 *          3.1:我们在类的构造器中，可以显示的使用“this(形参列表)” 方式，调用本类中的其他构造器
 *          3.2:构造器中不能通过“this(形参列表)”方式调用自己
 *          3.3：如果一个类中有n 个构造器，则最多有n-1 构造器使用了“this(形参列表)”
 *          规定：“this（形参列表）“必须声明在当前构造器的首行

一:package 关键字的使用
    * 1：使用package 声明类或接口所属的包，声明在源文件的首行
    * 2：包，属于标识符，遵循标识符的命名规则
    * 3：每"."一次，代表一层文件目录

二：import 关键字的使用
    * 1：在源文件中显式的使用import 结构导入指定包下的类，接口
    * 2：声明在包的声明和类的声明之间
    * 3：如果使用的类或接口是 java.lang 包下定义的，则可以省略import 结构
    * 4：如果使用的类或接口是本包下定义的，则可以省略 import 结构
    * 5：如果在源文件中，使用不同包下的同名的类，则必须至少有一个类需要以全类名(包含包名的类名)的方式显示
    *6：import static：导入指定类或接口中的静态结构:属性或方法

面向对象的特征之二：继承性
* 一：继承性的优势：
* 1：减少代码的冗余，提高了代码的复用性
* 2：便于功能的扩展
* 3：为之后的多态性的使用，提供了前提
* 二：继承性的格式：class A extends B{}
* A:子类，派生类
* B：父类，超类，基类
*     2.1体现：一旦子类A 继承了父类B 以后，子类A中就获取了父类B 中声明的结构：属性，方法
*      特别的，父类中声明为privated 的属性和方法，子类继承父类后，仍然认为获取了父类中私有的结构
*      只是因为封装性的影响，使得子类不能直接调用父类的结构而已
*    2.2 子类继承父类以后。还可以声明自己特有的属性或方法，实现功能的扩展
*     子类和父类的关系，不同于子集和集合的关系
*
* 三：java 中关于继承性的规定
* 1：一个类可以被多个子类继承
* 2：java 中的单继承性：一个类只有一个父类
* 3：子父类是相对的概念
* 4：子类继承父类，也就继承直接或间接父类中声明的所有属性和方法
*
*四：1:如果我么没有显式的声明一个类的父类，则此类继承于java.lang.Object 类
*   2：所有的java 类（java.lang.Object 类）,都直接或间接的继承于java.lang.Object类

*方法的重写（override/overwrite）
* 1：重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作
* 2：应用：重写以后，当创建子类对象以后，通过子类对象调用父类中的同名同参数的方法时，实际执行的是子类重写父类的方法
* 3：重写的规定：
*           方法的声明：权限修饰符 返回值类型 方法名（形参列表）throws 异常类型{
                    方法体
                    }
                    约定俗成：子类中的叫重写的方法，父类中的叫被重写的方法
                    * 1：:子类重写的方法名与形参列表与父类被重写的方法名与形参列表相同

                    * 2：权限修饰符：子类重写的方法权限修饰符不小于父类被重写的方法的权限修饰符

                    *              特殊情况：子类不能重写父类中声明为private权限的方法

                    * 3：返回值类型：
                    *               若父类被重写的方法的返回值类型时void ，则子类重写的方法返回值类型也是void
                    *               若父类被重写的方法的返回值类型是A类，则子类重写的方法返回值类型是A类或A类的子类
                    *               若父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法返回值必须是相同的基本数据类型

                    * 4：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型
                    *
                    * 额外的：子类和父类的同名同参数的要么声明为非static(考虑重写),要么生命为static(不是重写)

 super关键字的使用
* 1：super理解：父类的
* 2：super可以用来调用属性，方法，构造器
* 3：super 的使用:属性和方法
* 3.1 我们可以在子类的方法或构造器中，通过使用"super.属性"或"super.方法"的方式显示调用
*      父类声明的属性或方法，但是通常情况会省略"super."
* 3.2 特殊情况：当子类和父类中定义了同名的属性时，我们想在子类中调用父类中声明的属性，则必须
*      显示的使用"super.属性"的方式，表明调用的是父类中声明的属性
* 3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，必须
*      显示的使用"super.方法"的方式，表明调用的是父类中声明的方法
*
* 4：super 的使用：构造器
* 4.1 在子类的构造器中显示的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
* 4.2 "super（形参列表）"的使用，必须声明在子类构造器的首行
* 4.3 我们在类的构造器中，针对于"this（形参列表）"或super(形参列表)"只能二选一，不能同时出现
* 4.4 在构造器的首行，没有显示的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是 父类中空参的构造器：super()
* 4.5 在类的构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用了父类的构造器


子类对象实例化的全过程
* 1：从结果来看（继承性）
*       子类继承父类以后，就获取父类中升到属性和方法
*       创建子类的对象，在堆空间中，就会加载所有父类中声明的属性
* 2：从过程来看
*       当我们通过子类的构造器创建子类对象时，我么一定会直接或间接的调用其父类的构造器
        进而调用父类的父类的构造器。。，直到调用了java.lang.Object类中空间的构造器，正因为
        加载了所以父类的结构，所以才看到内存中父类的结构，子类对象才可以考虑进行调用
*

面向对象之三：多态性
* 1:理解多态性：可以理解为一个事物的多种形态
* 2:何为多态性：
*       对象多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）
* 3：多态的使用：虚拟方法调用
*       有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但是在运行期，我们实际执行的是子类重写父类的方法
*       总结：编译，看左边；运行，看右边
* 4：多态性使用的前提
*        1：类的继承关系，2：方法的重写
*
* 5:对象的多态性只适用于方法，不适用于属性（编译与运行都看左边）

有了对象的多态性后，内存中实际是加载了子类特有的属性和方法，但是由于变量声明为父类类型，
        //导致编译时，只能调用父类中声明的属性和方法，子类特有属性和方法不能调用

 如何调用子类特有的属性和方法
 向下转型：使用强制类型转换符
         instanceof关键字的使用
              a instanceof A:判断对象a是否是类A的实例，如果是，返回true ,如果不是，返回false
              使用情境：为了避免向下转型时出现ClassCastException的异常，我们在向下转型之前，进行
              instanceof的判断，一旦返回true,就进行向下转型，如果返回false,不进行向下转型

              如果a instanceof A,返回true,则 a instanceof B 也返回true (其中，类B是类A的父类)

重载与重写的区别
1；定义
2：具体规则
3：重载：不表现为多态性，重写：表现为多态性

java.lang.Object 类
1：Object 类是所有java类的父类
2：如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类
3:Object 类中的功能（属性，方法）具有通用性
属性：无
方法：equals()/toString()/getClass()/hashCode()/clone()/findlize()/wait()/notify()...
Object类 中只声明了一个空参构造器

面试题：== 与equals（）区别
一：回顾 == 的使用
1：可以使用在基本数据类型变量和引用数据类型变量中
2：如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等（不一定类型要相同）
   如果比较的是引用数据类型变量：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体

二：equals()方法的使用
1：是一个方法，而非运算符
2：只能使用引用数据类型
3:Object 类中equals（）的定义：
    public boolean equals(Object obj) {
        return (this == obj);
    }
    说明：Object类中定义的equals()方法与== 的作用是相同的，即两个引用是否指向同一个对象实体

4：对于如String,Date,File,包装类等都重写了Object类中的equals()方法，重写以后，比较的不是两个引用
    的地址是否相同，而是比较两个对象的"实体内容"是否相同

5：通常情况下，我们自定义的类如果使用equals()的话，也通常比较两个对象的"实体内容"是否相同，
    那么，我们需要重写Object 类中equals()方法

* Object 类中toString ()的使用
* 1：当我们输出一个对象的引用时，实际上就是调用当前对象的toString()
* 2：Object 类中toString()的定义：
*       public String toString() {
            return getClass().getName() + "@" + Integer.toHexString(hashCode());
        }
  3： 对于String,Date,File,包装类等重写了Object 类中的toString ()方法,使得在调用对象的toString()时，返回"实体内容"信息

 * 4：自定义类也可以重写toString()方法，当调用此方法时，返回对象的"实体内容"

 包装类的使用
 * java 提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征
 * 掌握的：基本数据类型，包装类，String 三者之间的互相转换
 注意：转换时，可能会报NumberFormatException

 基本数据类型，包装类--->String类型：
             调用String重载的valueOf(xxx)
 String 类型--->基本数据类型，包装类:
              调用包装类的parseXxx()

 Java 5.0新特性：自动装箱与自动拆箱
 自动装箱:
        基本数据类型--->包装类
 自动拆箱：
        包装类--->基本数据类型
补充：  Interger内部定了IntergerCache结构，IntergerCache
          * 中定义了Interger[],保存了从-127-128范围的整数，如果我们使用自动装箱的方式，
          * 给Interger赋值的范围在-128-127范围内时，可以直接数组中的元素，不用再去new了
          * 目的：提高效率


















